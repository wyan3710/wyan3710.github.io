<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="王兴隆的博客">
    <meta name="keyword"  content="腾讯">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        进程线程协程 - 王兴隆的博客 | wangxinglong&#39;s Blog
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> sometimes code， sometimes design </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar radius">
            <img src="/img/avatar.jpg" />
        </div>
        <div class="name">
            <i>Wangxinglong</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/archive">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Python中-进程-线程-协程-多任务概念-重点"><span class="toc-text">Python中 进程 线程 协程 (多任务概念/重点)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#进程，是执行中的计算机程序。也就是说，每个代码在执行的时候，首先本身即是一个进程。"><span class="toc-text">进程，是执行中的计算机程序。也就是说，每个代码在执行的时候，首先本身即是一个进程。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#进程间通信"><span class="toc-text">进程间通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程队列queue"><span class="toc-text">进程队列queue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#管道pipe"><span class="toc-text">管道pipe</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#共享数据manage"><span class="toc-text">共享数据manage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程池"><span class="toc-text">进程池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程"><span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池"><span class="toc-text">线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多线程通信"><span class="toc-text">多线程通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#共享变量"><span class="toc-text">共享变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#变量共享引申出线程同步问题"><span class="toc-text">变量共享引申出线程同步问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#队列"><span class="toc-text">队列</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程和线程的区别"><span class="toc-text">进程和线程的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#协程"><span class="toc-text">协程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#python中的协程"><span class="toc-text">python中的协程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#协程异常处理"><span class="toc-text">协程异常处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#greenlet框架实现协程（封装yield的基础库）"><span class="toc-text">greenlet框架实现协程（封装yield的基础库）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基于greenlet框架的高级库gevent模块"><span class="toc-text">基于greenlet框架的高级库gevent模块</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#原生协程"><span class="toc-text">原生协程</span></a></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>

        <div class="index-about-mobile">
            <i> sometimes code， sometimes design </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        进程线程协程
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2017-12-23 08:00:00</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#python中高级面试题" title="python中高级面试题">python中高级面试题</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content ">
        <!-- toc -->
<h1 id="Python中-进程-线程-协程-多任务概念-重点"><a href="#Python中-进程-线程-协程-多任务概念-重点" class="headerlink" title="Python中 进程 线程 协程 (多任务概念/重点)"></a>Python中 进程 线程 协程 (多任务概念/重点)</h1><h2 id="进程，是执行中的计算机程序。也就是说，每个代码在执行的时候，首先本身即是一个进程。"><a href="#进程，是执行中的计算机程序。也就是说，每个代码在执行的时候，首先本身即是一个进程。" class="headerlink" title="进程，是执行中的计算机程序。也就是说，每个代码在执行的时候，首先本身即是一个进程。"></a>进程，是执行中的计算机程序。也就是说，每个代码在执行的时候，首先本身即是一个进程。</h2><p>一个进程具有:就绪，运行，中断，僵死，结束等状态(不同操作系统不一样)。</p>
<p>生命周期：</p>
<p>用户编写代码(代码本身是以进程运行的)</p>
<p>启动程序，进入进程“就绪”状态</p>
<p>操作系统调度资源，做“程序切换”，使得进程进入“运行”状态</p>
<p>结束/中断</p>
<p>特性</p>
<p>每个程序，本身首先是一个进程</p>
<p>运行中每个进程都拥有自己的地址空间、内存、数据栈及其它资源。</p>
<p>操作系统本身自动管理着所有的进程(不需要用户代码干涉)，并为这些进程合理分配可以执行时间。</p>
<p>进程可以通过派生新的进程来执行其它任务，不过每个进程还是都拥有自己的内存和数据栈等。</p>
<p>进程间可以通讯(发消息和数据)，采用 进程间通信(IPC) 方式。</p>
<p>说明</p>
<p>多个进程可以在不同的 CPU 上运行，互不干扰</p>
<p>同一个CPU上，可以运行多个进程，由操作系统来自动分配时间片</p>
<p>由于进程间资源不能共享，需要进程间通信，来发送数据，接受消息等</p>
<p>多进程，也称为“并行”。</p>
<h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>进程彼此之间互相隔离，要实现进程间通信（IPC），multiprocessing模块支持两种形式：队列和管道，这两种方式都是使用消息传递的。</p>
<h3 id="进程队列queue"><a href="#进程队列queue" class="headerlink" title="进程队列queue"></a>进程队列queue</h3><p>不同于线程queue，进程queue的生成是用multiprocessing模块生成的。</p>
<p>在生成子进程的时候，会将代码拷贝到子进程中执行一遍，及子进程拥有和主进程内容一样的不同的名称空间。</p>
<p>multiprocess.Queue 是跨进程通信队列</p>
<p>常用方法</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">q</span>.put方法用以插入数据到队列中，put方法还有两个可选参数：blocked和timeout。如果blocked为True（默认值），并且timeout为正值，该方法会阻塞timeout指定的时间，直到该队列有剩余的空间。如果超时，会抛出Queue.Full异常。如果blocked为False，但该Queue已满，会立即抛出Queue.Full异常。</span><br><span class="line"><span class="selector-tag">q</span>.get方法可以从队列读取并且删除一个元素。同样，get方法有两个可选参数：blocked和timeout。如果blocked为True（默认值），并且timeout为正值，那么在等待时间内没有取到任何元素，会抛出Queue.Empty异常。如果blocked为False，有两种情况存在，如果Queue有一个值可用，则立即返回该值，否则，如果队列为空，则立即抛出Queue.Empty异常.</span><br><span class="line"><span class="selector-tag">q</span>.get_nowait():同<span class="selector-tag">q</span>.get(False)</span><br><span class="line"><span class="selector-tag">q</span>.put_nowait():同<span class="selector-tag">q</span>.put(False)</span><br><span class="line"><span class="selector-tag">q</span>.empty():调用此方法时q为空则返回True，该结果不可靠，比如在返回True的过程中，如果队列中又加入了项目。</span><br><span class="line"><span class="selector-tag">q</span>.full()：调用此方法时q已满则返回True，该结果不可靠，比如在返回True的过程中，如果队列中的项目被取走。</span><br><span class="line"><span class="selector-tag">q</span>.qsize():返回队列中目前项目的正确数量，结果也不可靠，理由同<span class="selector-tag">q</span>.empty()和<span class="selector-tag">q</span>.full()一样</span><br></pre></td></tr></table></figure>
<h3 id="管道pipe"><a href="#管道pipe" class="headerlink" title="管道pipe"></a>管道pipe</h3><p>管道就是管道，就像生活中的管道，两头都能进能出</p>
<p>默认管道是全双工的，如果创建管道的时候映射成False，左边只能用于接收，右边只能用于发送，类似于单行道</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(sk)</span>:</span></span><br><span class="line">    sk.send(<span class="string">'hello world'</span>)</span><br><span class="line">    print(sk.recv())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    conn1,conn2=multiprocessing.Pipe()    <span class="comment">#开辟两个口，都是能进能出，括号中如果False即单向通信</span></span><br><span class="line">    p=multiprocessing.Process(target=foo,args=(conn1,))  <span class="comment">#子进程使用sock口，调用foo函数</span></span><br><span class="line">    p.start()</span><br><span class="line">    print(conn2.recv())  <span class="comment">#主进程使用conn口接收</span></span><br><span class="line">    conn2.send(<span class="string">'hi son'</span>) <span class="comment">#主进程使用conn口发送</span></span><br></pre></td></tr></table></figure>
<p>常用方法</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">conn1</span><span class="selector-class">.recv</span>():接收<span class="selector-tag">conn2</span><span class="selector-class">.send</span>(obj)发送的对象。如果没有消息可接收，<span class="selector-tag">recv</span>方法会一直阻塞。如果连接的另外一端已经关闭，那么<span class="selector-tag">recv</span>方法会抛出<span class="selector-tag">EOFError</span>。</span><br><span class="line"><span class="selector-tag">conn1</span><span class="selector-class">.send</span>(obj):通过连接发送对象。<span class="selector-tag">obj</span>是与序列化兼容的任意对象</span><br><span class="line">注意：<span class="selector-tag">send</span>()和<span class="selector-tag">recv</span>()方法使用<span class="selector-tag">pickle</span>模块对对象进行序列化</span><br></pre></td></tr></table></figure>
<h3 id="共享数据manage"><a href="#共享数据manage" class="headerlink" title="共享数据manage"></a>共享数据manage</h3><p>Queue和pipe只是实现了数据交互，并没实现数据共享，即一个进程去更改另一个进程的数据。</p>
<p>注：进程间通信应该尽量避免使用共享数据的方式</p>
<h3 id="进程池"><a href="#进程池" class="headerlink" title="进程池"></a>进程池</h3><p>开多进程是为了并发，通常有几个cpu核心就开几个进程，但是进程开多了会影响效率，主要体现在切换的开销，所以引入进程池限制进程的数量。</p>
<p>进程池内部维护一个进程序列，当使用时，则去进程池中获取一个进程，如果进程池序列中没有可供使用的进进程，那么程序就会等待，直到进程池中有可用进程为止。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程，是在进程中执行的代码。</p>
<p>一个进程下可以运行多个线程，这些线程之间共享主进程内申请的操作系统资源。</p>
<p>在一个进程中启动多个线程的时候，每个线程按照顺序执行。现在的操作系统中，也支持线程抢占，也就是说其它等待运行的线程，可以通过优先级，信号等方式，将运行的线程挂起，自己先运行。</p>
<p>使用</p>
<p>用户编写包含线程的程序(每个程序本身都是一个进程)</p>
<p>操作系统“程序切换”进入当前进程</p>
<p>当前进程包含了线程，则启动线程</p>
<p>多个线程，则按照顺序执行，除非抢占</p>
<p>特性</p>
<p>线程，必须在一个存在的进程中启动运行</p>
<p>线程使用进程获得的系统资源，不会像进程那样需要申请CPU等资源</p>
<p>线程无法给予公平执行时间，它可以被其他线程抢占，而进程按照操作系统的设定分配执行时间</p>
<p>每个进程中，都可以启动很多个线程</p>
<p>说明</p>
<p>多线程，也被称为”并发“执行。</p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>系统启动一个新线程的成本是比较高的，因为它涉及与操作系统的交互。在这种情形下，使用线程池可以很好地提升性能，尤其是当程序中需要创建大量生存期很短暂的线程时，更应该考虑使用线程池。</p>
<p>线程池在系统启动时即创建大量空闲的线程，程序只要将一个函数提交给线程池，线程池就会启动一个空闲的线程来执行它。当该函数执行结束后，该线程并不会死亡，而是再次返回到线程池中变成空闲状态，等待执行下一个函数。</p>
<p>此外，使用线程池可以有效地控制系统中并发线程的数量。当系统中包含有大量的并发线程时，会导致系统性能急剧下降，甚至导致 Python 解释器崩溃，而线程池的最大线程数参数可以控制系统中并发线程的数量不超过此数。</p>
<h3 id="多线程通信"><a href="#多线程通信" class="headerlink" title="多线程通信"></a>多线程通信</h3><h4 id="共享变量"><a href="#共享变量" class="headerlink" title="共享变量"></a>共享变量</h4><p>创建全局变量，多个线程公用一个全局变量，方便简单。但是坏处就是共享变量容易出现数据竞争，不是线程安全的，解决方法就是使用互斥锁。</p>
<h4 id="变量共享引申出线程同步问题"><a href="#变量共享引申出线程同步问题" class="headerlink" title="变量共享引申出线程同步问题"></a>变量共享引申出线程同步问题</h4><p>如果多个线程共同对某个数据修改，则可能出现不可预料的结果，为了保证数据的正确性，需要对多个线程进行同步。 使用Thread对象的Lock和Rlock可以实现简单的线程同步，这两个对象都有acquire方法和release方法，对于那些需要每次只允许一个线程操作的数据，可以将其操作放到acquire和release方法之间。</p>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>线程间使用队列进行通信，因为队列所有方法都是线程安全的，所以不会出现线程竞争资源的情况</p>
<p>Queue.Queue 是进程内非阻塞队列</p>
<h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><p>一个进程中的各个线程与主进程共享相同的资源，与进程间互相独立相比，线程之间信息共享和通信更加容易(都在进程中，并且共享内存等)。</p>
<p>线程一般以并发执行，正是由于这种并发和数据共享机制，使多任务间的协作成为可能。</p>
<p>进程一般以并行执行，这种并行能使得程序能同时在多个CPU上运行;</p>
<p>区别于多个线程只能在进程申请到的的“时间片”内运行(一个CPU内的进程，启动了多个线程，线程调度共享这个进程的可执行时间片)，进程可以真正实现程序的“同时”运行(多个CPU同时运行)。</p>
<p>进程和线程的常用应用场景</p>
<p>一般来说,在Python中编写并发程序的经验:</p>
<p>计算密集型任务使用多进程</p>
<p>IO密集型(如:网络通讯)任务使用多线程，较少使用多进程.</p>
<p>这是由于 IO操作需要独占资源，比如:</p>
<p>网络通讯(微观上每次只有一个人说话，宏观上看起来像同时聊天)每次只能有一个人说话</p>
<p>文件读写同时只能有一个程序操作(如果两个程序同时给同一个文件写入 ‘a’, ‘b’，那么到底写入文件的哪个呢?)</p>
<p>都需要控制资源每次只能有一个程序在使用，在多线程中，由主进程申请IO资源，多线程逐个执行，哪怕抢占了，也是逐个运行，感觉上“多线程”并发执行了。</p>
<p>如果多进程，除非一个进程结束，否则另外一个完全不能用，显然多进程就“浪费”资源了。</p>
<p>当然如上解释可能还不足够立即理解问题所在，让我们通过不断的实操来体验其中的“门道”。</p>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>协程: 协程，又称微线程，纤程，英文名Coroutine。协程的作用，是在执行函数A时，可以随时中断，去执行函数B，然后中断继续执行函数A（可以自由切换）。但这一过程并不是函数调用（没有调用语句），这一整个过程看似像多线程，然而协程只有一个线程执行.</p>
<p>协程由于由程序主动控制切换，没有线程切换的开销，所以执行效率极高。对于IO密集型任务非常适用，如果是cpu密集型，推荐多进程+协程的方式。</p>
<p>协程，又称微线程。</p>
<p>说明</p>
<p>协程的主要特色是:</p>
<p>协程间是协同调度的，这使得并发量数万以上的时候，协程的性能是远远高于线程。</p>
<p>注意这里也是“并发”，不是“并行”。</p>
<p>常用库：greenlet gevent</p>
<p>协程优点：</p>
<p>　　1. 协程的切换开销更小，属于程序级别的切换，操作系统完全感知不到，因而更加轻量级</p>
<p>　　2. 单线程内就可以实现并发的效果，最大限度地利用cpu</p>
<p>协程缺点：</p>
<p>　　1.协程的本质是单线程下，无法利用多核，可以是一个程序开启多个进程，每个进程内开启多个线程，每个线程内开启协程</p>
<p>　　2.协程指的是单个线程，因而一旦协程出现阻塞，将会阻塞整个线程</p>
<h2 id="python中的协程"><a href="#python中的协程" class="headerlink" title="python中的协程"></a>python中的协程</h2><p>一个协程是一个函数/子程序（可以认为函数和子程序是指一个东西）。这个函数可以暂停执行， 把执行权让给 YieldInstruction，等 YieldInstruction 执行完成后，这个函数可以继续执行。 这个函数可以多次这样的暂停与继续。</p>
<p>注：这里的 YieldInstruction, 我们其实也可以简单理解为函数。</p>
<p>协程可以在“卡住”的时候可以干其它事情。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">long_task</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'long task started'</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'long task finished'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>loop.create_task(long_task())</span><br><span class="line">&lt;Task pending coro=&lt;long_task() running at &lt;stdin&gt;:<span class="number">1</span>&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>loop.create_task(job1())                                                                                                                                                                                                                            &gt;&gt;&gt;&gt;&gt; loop.create_task(job1())</span><br><span class="line">&lt;Task pending coro=&lt;job1() running at &lt;stdin&gt;:<span class="number">1</span>&gt;&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>    loop.run_forever()</span><br><span class="line"><span class="meta">... </span><span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line">long task started</span><br><span class="line">job1 started...</span><br><span class="line">job1 paused</span><br><span class="line">hello world</span><br><span class="line">job1 resumed</span><br><span class="line">job1 finished</span><br><span class="line">long task finished</span><br></pre></td></tr></table></figure>
<p>从这段程序的输出可以看出，程序本来是在执行 long task 协程，但由于 long task 要 await sleep 1 秒，于是 long task 自动暂停了，hello_world 协程自动开始执行， hello world 执行完之后，long task 继续执行。</p>
<p>协程有两种定义的方法， 其中使用生成器形式定义的协程叫做 generator-based coroutine, 通过 async/await 声明的协程叫做 native coroutine，两者底层实现都是生成器。接着， 我们阐述了协程的概念，从概念和例子出发，讲了协程和生成器最主要的特征：可以暂停执行和恢复执行。</p>
<h3 id="协程异常处理"><a href="#协程异常处理" class="headerlink" title="协程异常处理"></a>协程异常处理</h3><p>使用协程的时候一定加了很多的异常,但百密而一疏,总是会有想象不到的异常发生,这个时候为了不让程序整体崩溃应该使用协程的额外异常处理方法,这个方法会去执行绑定的回调函数.</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">g_dict=dict&#123;&#125;</span><br><span class="line">g = gevent.spawn(<span class="keyword">self</span>._g_fetcher, feed_name)   <span class="comment"># 创建协程</span></span><br><span class="line">g_dict[feed_name] = [g,False]</span><br><span class="line">g.link_exception(<span class="keyword">self</span>._link_exception_callback)  <span class="comment"># 给该协程添加出现处理不了的异常时候的回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_link_exception_callback</span><span class="params">(<span class="keyword">self</span>, g)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="comment"># 可能遇到无法修复的错误，需要修改代码 todo 报警</span></span><br><span class="line">    <span class="comment"># 可以在这个函数里面做一些错误异常的打印,或者文件的关闭,连接的关闭.</span></span><br><span class="line">    <span class="keyword">self</span>.terminated_flag = True <span class="comment"># 停止整个程序 让 supervior重启</span></span><br><span class="line">    logger.info(<span class="string">"_link_exception_callback &#123;0&#125; &#123;1&#125;"</span>.format(g, g.exception))</span><br><span class="line">    <span class="keyword">self</span>._kill_sleep_gevent()   <span class="comment"># 轮询结束休眠的协程</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_kill_sleep_gevent</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="keyword">for</span> i,is_sleep <span class="keyword">in</span> g_dict.items()<span class="symbol">:</span></span><br><span class="line">        <span class="keyword">if</span> is_sleep[<span class="number">1</span>] == <span class="string">"True"</span><span class="symbol">:</span></span><br><span class="line">            gevent.kill(is_sleep[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<h3 id="greenlet框架实现协程（封装yield的基础库）"><a href="#greenlet框架实现协程（封装yield的基础库）" class="headerlink" title="greenlet框架实现协程（封装yield的基础库）"></a>greenlet框架实现协程（封装yield的基础库）</h3><p>greenlet机制的主要思想是：生成器函数或者协程函数中的yield语句挂起函数的执行，直到稍后使用next()或send()操作进行恢复为止。可以使用一个调度器循环在一组生成器函数之间协作多个任务。greentlet是python中实现我们所谓的”Coroutine(协程)”的一个基础库。</p>
<h3 id="基于greenlet框架的高级库gevent模块"><a href="#基于greenlet框架的高级库gevent模块" class="headerlink" title="基于greenlet框架的高级库gevent模块"></a>基于greenlet框架的高级库gevent模块</h3><p>gevent是第三方库，通过greenlet实现协程，其基本思想是：</p>
<p>当一个greenlet遇到IO操作时，比如访问网络，就自动切换到其他的greenlet，等到IO操作完成，再在适当的时候切换回来继续执行。由于IO操作非常耗时，经常使程序处于等待状态，有了gevent为我们自动切换协程，就保证总有greenlet在运行，而不是等待IO。</p>
<h1 id="原生协程"><a href="#原生协程" class="headerlink" title="原生协程"></a>原生协程</h1><p>协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存，在调度回来的时候，恢复先前保存的寄存器上下文和栈。因此协程能保留上一次调用时的状态，即所有局部状态的一个特定组合</p>
<p>async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job</span><span class="params">(t)</span>:</span></span><br><span class="line">    time.sleep(t) </span><br><span class="line">    print(<span class="string">'用了%s'</span> % t)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    [job(t) <span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">3</span>)]</span><br><span class="line">start = time.time()</span><br><span class="line">main()</span><br><span class="line">print(time.time()-start)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">job</span><span class="params">(t)</span>:</span>  <span class="comment"># 使用 async 关键字将一个函数定义为协程</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(t)  <span class="comment"># 等待 t 秒, 期间切换执行其他任务</span></span><br><span class="line">    print(<span class="string">'用了%s秒'</span> % t)</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(loop)</span>:</span>  <span class="comment"># 使用 async 关键字将一个函数定义为协程</span></span><br><span class="line">    tasks = [loop.create_task(job(t)) <span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">3</span>)]  <span class="comment"># 创建任务, 不立即执行</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.wait(tasks)  <span class="comment"># 执行并等待所有任务完成</span></span><br><span class="line">start = time.time()</span><br><span class="line">loop = asyncio.get_event_loop()  <span class="comment"># 建立 loop</span></span><br><span class="line">loop.run_until_complete(main(loop))  <span class="comment"># 执行 loop</span></span><br><span class="line">loop.close()  <span class="comment"># 关闭 loop</span></span><br><span class="line"></span><br><span class="line">print(time.time()-start)</span><br></pre></td></tr></table></figure>

        
            <div class="donate-container">
    <div class="donate-button">
        <button id="donate-button">赞赏</button>
    </div>
    <div class="donate-img-container hide" id="donate-img-container">
        <img id="donate-img" src="" data-src="/img/donate.jpg">
        <p> 感谢鼓励 </p>
    </div>
</div>
        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>

        <div id="lv-container">
        </div>

    </div>
</div>

    </div>
</div>

<footer class="footer">
    <ul class="list-inline text-center">
        
                

                        
                            <li>
                                <a target="_blank" href="http://weibo.com/7300791812">
                                    <span class="fa-stack fa-lg">
                                  <i class="iconfont icon-weibo"></i>
                            </span>
                                </a>
                            </li>
                            

                                

                                        
                                            <li>
                                                <a target="_blank" href="https://github.com/wyan3710">
                                                    <span class="fa-stack fa-lg">
                                <i class="iconfont icon-github"></i>
                            </span>
                                                </a>
                                            </li>
                                            

                                                

    </ul>
    
        <p>
            <span>/</span>
            
                <span><a href="https://www.10000h.top">10000H</a></span>
                <span>/</span>
                
                <span><a href="https://niexiaotao.com">LaoWang&#39;s Page</a></span>
                <span>/</span>
                
                <span><a href="#">It helps SEO</a></span>
                <span>/</span>
                
        </p>
        
            <p>
                <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
                </span>
                <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
                </span>
                Created By <a href="https://hexo.io/">Hexo</a> Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>



            <img src="https://static.dy208.cn/o_1dfilp8ruo521thr1hvf18ji17soa.png">
            <a href="http://www.beian.miit.gov.cn/" style="color:#f72b07" target="_blank">京ICP备19052615号</a>
</footer>

</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


    <script>
        /**
         *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
         *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
        */
        if( '' || '')
        var disqus_config = function () {
            this.page.url = '';  // Replace PAGE_URL with your page's canonical URL variable
            this.page.identifier = ''; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
        };

        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document, s = d.createElement('script');
            s.src = 'https://airclouds-blog.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();
    </script>



</html>
